<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyqrypto.rOperations &mdash; pyqrypto 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/documentation_options.js?v=2709fde1"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyqrypto
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../rOperations.html">rOperations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparkle.html">Sparkle</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyqrypto</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyqrypto.rOperations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyqrypto.rOperations</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A library of vectorial operations that can be applied to quantum registers.</span>

<span class="sd">In this library, a :class:`QuantumRegister` from `Qiskit &lt;https://qiskit.org/&gt;`_ is seen as a view on a vector of qubits. Operations can be applied directly between registers, for example a bitwise XOR or an addition. This is similar to how registers work on classical computers. Rotations, and permutations in general, can be made without using any quantum gate because they just return a new view on the qubits, i.e. a new :class:`QuantumRegister` that has the same logical qubits but in a different order.</span>

<span class="sd">The aim of this library is to be able to implement classical algorithms on quantum computers, to benefit from the speedup given by methods such as Grover&#39;s algorithm.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">AncillaRegister</span><span class="p">,</span> <span class="n">transpile</span>
<span class="kn">from</span> <span class="nn">qiskit_aer.backends</span> <span class="kn">import</span> <span class="n">AerSimulator</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">Gate</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">Barrier</span><span class="p">,</span> <span class="n">CCXGate</span>
<span class="kn">from</span> <span class="nn">qiskit.result.counts</span> <span class="kn">import</span> <span class="n">Counts</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.exceptions</span> <span class="kn">import</span> <span class="n">CircuitError</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Final</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span><span class="p">,</span> <span class="n">log2</span>

<span class="n">FEYNMAN_QC</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;The quantum cost of the Feynman gate (CNOT).&quot;&quot;&quot;</span>
<span class="n">TOFFOLI_QC</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="sd">&quot;&quot;&quot;The quantum cost of the Toffoli gate (CCNOT).&quot;&quot;&quot;</span>
<span class="n">SINGLE_QC</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;The quantum cost of a single qubit gate.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_int_to_bits</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_bits</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert integer k into list of bits in LSB-first.</span>

<span class="sd">    :param k: The integer to convert to list of bits.</span>
<span class="sd">    :param num_bits: The numbers of bits to use to encode k.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure k is in range</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">**</span><span class="n">num_bits</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> cannot be encoded on </span><span class="si">{</span><span class="n">num_bits</span><span class="si">}</span><span class="s2"> bits.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="s1">&#39;{:0</span><span class="si">{n}</span><span class="s1">b}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">num_bits</span><span class="p">)][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_hamming_weight</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the Hamming weight of an integer.</span>

<span class="sd">    :param k: The integer to compute the Hamming weight of.</span>
<span class="sd">    :returns: The Hamming weight of k.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">k</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">&amp;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">c</span>

<div class="viewcode-block" id="rCircuit">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rCircuit">[docs]</a>
<span class="k">class</span> <span class="nc">rCircuit</span><span class="p">(</span><span class="n">QuantumCircuit</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A wrapper around :class:`QuantumCircuit` that implements the logic needed to chain operations on qubit vectors. It supports new operations that operate on whole quantum registers and handles rotations without using any gate by rewiring the circuit when needed. This being also a fully valid :class:`QuantumCircuit`, it is also possible to apply operations on single qubits as it is normally done in Qiskit.</span>

<span class="sd">    :param inputs: The quantum registers to use as the circuit inputs.</span>
<span class="sd">    :param kwargs: Other parameters to pass to the underlying :class:`QuantumCircuit` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Some statistics about the circuit:</span>

<span class="sd">        - :py:data:`quantum_cost`: The quantum cost of the circuit as defined by [FoM2009]_.</span>
<span class="sd">        - :py:data:`depth`: The circuit depth when rOperations are decomposed into NOT, CNOT and CCNOT gates.</span>
<span class="sd">        - :py:data:`gate_counts`: The number of basic gates in the circuit.</span>

<span class="sd">        .. warning:: Quantum cost computation only works if the circuit contains only rOperations or NOT, CNOT, and CCNOT gates.</span>

<span class="sd">        .. [FoM2009] Mohammadi, M., &amp; Eshghi, M. (2009). On figures of merit in reversible and quantum logic designs. Quantum Information Processing, 8, 297-318.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;ancilla&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancillas</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;qubits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancillas</span>

        <span class="c1"># Decompose all rOperations in the circuit</span>
        <span class="n">decomposed_circuit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">gates_to_decompose</span><span class="o">=</span><span class="p">[</span><span class="n">rOperation</span><span class="p">])</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="n">decomposed_circuit</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instruction</span><span class="o">.</span><span class="n">operation</span><span class="p">,</span> <span class="n">rOperation</span><span class="p">):</span>
                    <span class="n">decomposed_circuit</span> <span class="o">=</span> <span class="n">decomposed_circuit</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">gates_to_decompose</span><span class="o">=</span><span class="p">[</span><span class="n">rOperation</span><span class="p">])</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
        <span class="n">operations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">decomposed_circuit</span><span class="o">.</span><span class="n">count_ops</span><span class="p">())</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;gate_counts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">operations</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;quantum_cost&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">operation</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">operations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s1">&#39;cx&#39;</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">FEYNMAN_QC</span>
            <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s1">&#39;ccx&#39;</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">TOFFOLI_QC</span>
            <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">SINGLE_QC</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot compute quantum cost for operation </span><span class="si">{</span><span class="n">operation</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>   
            <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;quantum_cost&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">k</span><span class="o">*</span><span class="n">count</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decomposed_circuit</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
        <span class="c1"># Some papers only count toffoli gates for the circuit depth</span>
        <span class="n">ccx_only</span> <span class="o">=</span> <span class="n">decomposed_circuit</span><span class="o">.</span><span class="n">copy_empty_like</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span> <span class="ow">in</span> <span class="n">decomposed_circuit</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">CCXGate</span><span class="p">):</span>
                <span class="n">ccx_only</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span><span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;toffoli_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ccx_only</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">stats</span>

<div class="viewcode-block" id="rCircuit.ror">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rCircuit.ror">[docs]</a>
    <span class="k">def</span> <span class="nf">ror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumRegister</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Rotate right a register by a specified amount of qubits.</span>

<span class="sd">        :param X: The register to rotate.</span>
<span class="sd">        :param r: The number of qubits by which X should be rotated.</span>
<span class="sd">        :returns: The rotated register :math:`X&#39;`.</span>

<span class="sd">        :operation: :math:`X&#39; \leftarrow \mathrm{ror}(X, r)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">rROR</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="rCircuit.rol">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rCircuit.rol">[docs]</a>
    <span class="k">def</span> <span class="nf">rol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumRegister</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Rotate left a register by a specified amount of qubits.</span>

<span class="sd">        :param X: The register to rotate.</span>
<span class="sd">        :param r: The number of qubits by which X should be rotated.</span>
<span class="sd">        :returns: The rotated register :math:`X&#39;`.</span>

<span class="sd">        :operation: :math:`X&#39; \leftarrow \mathrm{rol}(X, r)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">rROL</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="rCircuit.xor">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rCircuit.xor">[docs]</a>
    <span class="k">def</span> <span class="nf">xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">Y</span><span class="p">:</span> <span class="n">QuantumRegister</span> <span class="o">|</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumRegister</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a bitwise XOR between two registers or between one register and a constant and store the result in the first register.</span>

<span class="sd">        :param X: The first register to XOR (the result will be stored in this register, overwriting its previous value).</span>
<span class="sd">        :param Y: The second register to XOR or a constant.</span>
<span class="sd">        :returns: The output register :math:`X`.</span>

<span class="sd">        :operation: :math:`X \leftarrow X \oplus Y`</span>

<span class="sd">        .. note::</span>
<span class="sd">            If Y is a :class:`QuantumRegister`, this operation is a XOR between two registers, but if Y is an integer it becomes a XOR between a register and a constant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">rXOR</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">rConstantXOR</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="rCircuit.neg">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rCircuit.neg">[docs]</a>
    <span class="k">def</span> <span class="nf">neg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumRegister</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a bitwise NOT on a register.</span>

<span class="sd">        :param X: The register to apply the NOT to.</span>
<span class="sd">        :returns: The output register :math:`X`.</span>

<span class="sd">        :operation: :math:`X \leftarrow \neg X`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">rNOT</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="rCircuit.add">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rCircuit.add">[docs]</a>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">Y</span><span class="p">:</span> <span class="n">QuantumRegister</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AncillaRegister</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;ripple&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumRegister</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Add modulo :math:`2^n` two registers of size n or a register of size n and a constant and store the result in the first register.</span>

<span class="sd">        The adder can be implemented using different techniques:</span>

<span class="sd">        - :py:data:`ripple`: requires 0 ancilla qubits, uses the ripple-carry method from [TTK2009]_.</span>
<span class="sd">        - :py:data:`lookahead`: requires :math:`2n-w(n-1)-\lfloor \log(n-1) \rfloor-2` ancilla qubits, uses the carry-lookahead method from [DKRS2004]_.</span>

<span class="sd">        :param X: First register to add (the result will be stored in this register, overwriting its previous value).</span>
<span class="sd">        :param Y: Second register to add or a constant.</span>
<span class="sd">        :param ancillas: The anquilla register needed in :py:data:`lookahead` mode.</span>
<span class="sd">        :mode: The type of adder to use.</span>
<span class="sd">        :returns: The output register :math:`X`.</span>

<span class="sd">        :operation: :math:`X \leftarrow X+Y \bmod 2^n`</span>

<span class="sd">        .. note::</span>
<span class="sd">            If Y is a :class:`QuantumRegister`, this operation is an addition between two registers, but if Y is an integer it becomes an addition between a register and a constant. In the latter case, the mode is always :py:data:`lookahead`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;ripple&#39;</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">rTTKRippleCarryAdder</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;lookahead&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ancillas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="s2">&quot;Cannot make a carry-lookahead adder without ancilla qubits.&quot;</span><span class="p">)</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">rDKRSCarryLookaheadAdder</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown adder mode </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ancillas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="s2">&quot;Cannot make a constant adder without ancilla qubits.&quot;</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">rConstantDKRSCarryLookaheadAdder</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
</div>


<div class="viewcode-block" id="rOperation">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rOperation">[docs]</a>
<span class="k">class</span> <span class="nc">rOperation</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract class defining an operation on registers of qubits.</span>
<span class="sd">    </span>
<span class="sd">    :ivar inputs: The inputs registers of the operation.</span>
<span class="sd">    :type inputs: Sequence[QuantumRegister]</span>
<span class="sd">    :ivar outputs: The outputs registers of the operation.</span>
<span class="sd">    :type outputs: Sequence[QuantumRegister]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span></div>


<div class="viewcode-block" id="rPrepare">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rPrepare">[docs]</a>
<span class="k">class</span> <span class="nc">rPrepare</span><span class="p">(</span><span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">rOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A circuit preparing a QuantumRegister to an initial classical integer value.</span>

<span class="sd">    :param X: The register to prepare.</span>
<span class="sd">    :param value: The value to prepare the register to.</span>

<span class="sd">    :operation: :math:`X \leftarrow \mathrm{value}`</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_qubits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;rPrepare </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">_int_to_bits</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">i</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">qc</span><span class="o">.</span><span class="n">qregs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;rPrepare </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">to_gate</span><span class="p">(),</span> <span class="n">qubits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span></div>


<div class="viewcode-block" id="rROR">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rROR">[docs]</a>
<span class="k">class</span> <span class="nc">rROR</span><span class="p">(</span><span class="n">rOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Defines the right rotation operation on a QuantumRegiser.</span>

<span class="sd">    :param X: The register to rotate.</span>
<span class="sd">    :param r: The number of qubits by which X should be rotated.</span>
<span class="sd">    :raises CircuitError: If r is negative.</span>

<span class="sd">    :operation: :math:`X&#39; \leftarrow \mathrm{ror}(X, r)`</span>

<span class="sd">    .. warning::</span>
<span class="sd">        The result will be stored in register :attr:`self.outputs[0]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="s2">&quot;Rotation must be by a positive amount.&quot;</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span><span class="o">+</span><span class="n">X</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span></div>


<div class="viewcode-block" id="rROL">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rROL">[docs]</a>
<span class="k">class</span> <span class="nc">rROL</span><span class="p">(</span><span class="n">rOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Defines the left rotation operation on a QuantumRegister.</span>

<span class="sd">    :param X: The register to rotate.</span>
<span class="sd">    :param r: The number of qubits by which X should be rotated.</span>
<span class="sd">    :raises CircuitError: If r is negative.</span>

<span class="sd">    :operation: :math:`X&#39; \leftarrow \mathrm{rol}(X, r)`</span>


<span class="sd">    .. warning::</span>
<span class="sd">        The result will be stored in register :attr:`self.outputs[0]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="s2">&quot;Rotation must be by a positive amount.&quot;</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="n">r</span><span class="p">:]</span><span class="o">+</span><span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="n">r</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span></div>


<div class="viewcode-block" id="rConstantXOR">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rConstantXOR">[docs]</a>
<span class="k">class</span> <span class="nc">rConstantXOR</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">rOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A gate implementing a logical bitwise XOR operation between a register of qubits and a constant.</span>
<span class="sd">    </span>
<span class="sd">    :param X: The register to XOR with c.</span>
<span class="sd">    :param c: The constant to XOR with X.</span>
<span class="sd">    :param label: An optional label for the gate.</span>

<span class="sd">    :operation: :math:`X \leftarrow X \oplus c`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;rXORc&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="n">bits</span> <span class="o">=</span> <span class="n">_int_to_bits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
    
        <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;rXOR </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
   
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bits</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bit</span><span class="p">:</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">qc</span></div>


<div class="viewcode-block" id="rNOT">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rNOT">[docs]</a>
<span class="k">class</span> <span class="nc">rNOT</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">rOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A gate implementing a bitwise NOT operation on a register</span>

<span class="sd">    :param X: The register to apply NOT on.</span>
<span class="sd">    :param label: An optional label for the gate.</span>

<span class="sd">    :oopoeration: :math:`X \leftarrow \neg X`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;rNOT&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rNOT&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">X</span><span class="p">:</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">qc</span></div>


<div class="viewcode-block" id="rXOR">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rXOR">[docs]</a>
<span class="k">class</span> <span class="nc">rXOR</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">rOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A gate implementing a logical bitwise XOR operation between two registers.</span>

<span class="sd">    :param X: The first register to XOR.</span>
<span class="sd">    :param Y: The second register to XOR.</span>
<span class="sd">    :param label: An optional label for the gate.</span>
<span class="sd">    :raises CircuitError: If X and Y have a different size.</span>

<span class="sd">    :operation: :math:`X \leftarrow X \oplus Y`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">Y</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="s2">&quot;rXOR operation must be between two QuantumRegisters of the same size.&quot;</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;rXOR&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rXOR&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">qc</span></div>


<div class="viewcode-block" id="rConstantDKRSCarryLookaheadAdder">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rConstantDKRSCarryLookaheadAdder">[docs]</a>
<span class="k">class</span> <span class="nc">rConstantDKRSCarryLookaheadAdder</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">rOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A gate implementing an addition modulo :math:`2^n` between a register of qubits and a constant.</span>
<span class="sd">    </span>
<span class="sd">    :param X: The register of size n to add c to.</span>
<span class="sd">    :param c: The constant to add to X.</span>
<span class="sd">    :param label: An optional label for the gate.</span>

<span class="sd">    :operation: :math:`X \leftarrow X + c`</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="rConstantDKRSCarryLookaheadAdder.get_num_ancilla_qubits">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rConstantDKRSCarryLookaheadAdder.get_num_ancilla_qubits">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_num_ancilla_qubits</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of required ancilla qubits without instantiating the class.</span>

<span class="sd">        :param n: The number of qubits of the vectors to add.</span>
<span class="sd">        :returns: The number of ancilla qubits needed for the computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">rDKRSCarryLookaheadAdder</span><span class="o">.</span><span class="n">get_num_ancilla_qubits</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">:</span> <span class="n">AncillaRegister</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;rADDc&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">),</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_ancilla_qubits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Circuit needs </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_ancilla_qubits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2"> ancilla qubits but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">)</span><span class="si">}</span><span class="s2"> were given.&quot;</span><span class="p">)</span>

        <span class="n">qc</span> <span class="o">=</span> <span class="n">rCircuit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;rADD </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
   
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bits</span> <span class="o">=</span> <span class="n">_int_to_bits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">ancillas</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">ancillas</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">::])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># Z[i] = g[i, i+1]</span>
                <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="c1"># A[i] = p[i, i+1] and A[0] = s0</span>

            <span class="c1"># Lookahead carry</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Compute carry</span>
                <span class="n">compute_carry</span> <span class="o">=</span> <span class="n">rDKRSComputeCarry</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Z</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute_carry</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">compute_carry</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>
            
                <span class="c1"># Compute sum</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">Z</span><span class="p">)</span> <span class="c1"># A[i] = si</span>
                <span class="c1"># Now do everything in reverse</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># A = s&#39;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">qc</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

                <span class="n">uncompute_carry</span> <span class="o">=</span> <span class="n">rDKRSComputeCarry</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Z</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">reverse_ops</span><span class="p">()</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uncompute_carry</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">uncompute_carry</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">qc</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">qc</span></div>


<div class="viewcode-block" id="rDKRSComputeCarry">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rDKRSComputeCarry">[docs]</a>
<span class="k">class</span> <span class="nc">rDKRSComputeCarry</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">rOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A gate implemented the carry computation described in [DKRS2004]_. The last carry is not computed.</span>

<span class="sd">    :param P0: :math:`P_0[i] = p[i, i+1]`, 1 if and only if carry propagages from bit :math:`i` to bit :math:`i+1`.</span>
<span class="sd">    :param G: :math:`G[i] = g[i-1, i]`, 1 if and only if a carry is generated between bit :math:`i-1` and bit :math:`i`.</span>
<span class="sd">    :param ancillas: The ancilla qubits used for the computation. They must be set to 0 before the circuit and will be reset to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P0</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">:</span> <span class="n">AncillaRegister</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;rCarry&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">),</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">P0</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">P0</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>

        <span class="n">qc</span> <span class="o">=</span> <span class="n">rCircuit</span><span class="p">(</span><span class="n">P0</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rCarry&#39;</span><span class="p">)</span>

        <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">P0</span><span class="p">]</span>
        <span class="n">ancilla_index</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))):</span>
            <span class="n">Pt_size</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">ancillas</span><span class="p">[</span><span class="n">ancilla_index</span><span class="p">:</span><span class="n">ancilla_index</span><span class="o">+</span><span class="n">Pt_size</span><span class="p">]))</span>
            <span class="n">ancilla_index</span><span class="o">+=</span><span class="n">Pt_size</span>

        <span class="c1"># P-rounds</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">)):</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># G-rounds</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">)):</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">*</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">],</span><span class="n">G</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">*</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># C rounds</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">/</span><span class="mi">3</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">*</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">*</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># P^-1 rounds</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">)):</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">qc</span></div>


<div class="viewcode-block" id="rDKRSCarryLookaheadAdder">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rDKRSCarryLookaheadAdder">[docs]</a>
<span class="k">class</span> <span class="nc">rDKRSCarryLookaheadAdder</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">rOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A gate implementing the n qubits carry-lookahead adder modulo :math:`2^n` described in [DKRS2004]_. This implementation skips the output carry compution.</span>


<span class="sd">    :param A: First register of size n to add.</span>
<span class="sd">    :param B: Second register of size n to add.</span>
<span class="sd">    :param ancillas: The ancilla qubits used for the computation. They must be set to 0 before the circuit and will be reset to 0.</span>
<span class="sd">    :param label: An optional label for the gate.</span>
<span class="sd">    :raises CircuitError: If A and B have a different size or if there is not the correct number of ancilla qubits.</span>

<span class="sd">    :operation: :math:`X \leftarrow X+Y \bmod 2^n`</span>

<span class="sd">    .. [DKRS2004] Draper, T. G., Kutin, S. A., Rains, E. M., &amp; Svore, K. M. (2004). A logarithmic-depth quantum carry-lookahead adder. arXiv preprint quant-ph/0406142.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="rDKRSCarryLookaheadAdder.get_num_ancilla_qubits">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rDKRSCarryLookaheadAdder.get_num_ancilla_qubits">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_num_ancilla_qubits</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of required ancilla qubits without instantiating the class.</span>

<span class="sd">        :param n: The number of qubits of the vectors to add.</span>
<span class="sd">        :returns: The number of ancilla qubits needed for the computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="n">_hamming_weight</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mi">2</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">:</span> <span class="n">AncillaRegister</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;rADD&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">),</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="s2">&quot;rADD operation must be between two QuantumRegisters of the same size.&quot;</span><span class="p">)</span> 
        <span class="n">qc</span> <span class="o">=</span> <span class="n">rCircuit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rADD&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_ancilla_qubits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="s2">&quot;Wrong number of ancilla qubits.&quot;</span><span class="p">)</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">ancillas</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">ancillas</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">::])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># Z[i] = g[i, i+1]</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="c1"># A[i] = p[i, i+1] and A[0] = s0</span>

        <span class="c1"># Lookahead carry</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Compute carry</span>
            <span class="n">compute_carry</span> <span class="o">=</span> <span class="n">rDKRSComputeCarry</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Z</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute_carry</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">compute_carry</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>
        
            <span class="c1"># Compute sum</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">Z</span><span class="p">)</span> <span class="c1"># A[i] = si</span>
            <span class="c1"># Now do everything in reverse</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># A = s&#39;</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

            <span class="n">uncompute_carry</span> <span class="o">=</span> <span class="n">rDKRSComputeCarry</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Z</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">reverse_ops</span><span class="p">()</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uncompute_carry</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">uncompute_carry</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>

            <span class="n">qc</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">qc</span></div>


<div class="viewcode-block" id="rTTKRippleCarryAdder">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.rTTKRippleCarryAdder">[docs]</a>
<span class="k">class</span> <span class="nc">rTTKRippleCarryAdder</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">rOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A gate implementing the n qubits ripple-carry adder modulo :math:`2^n` described in [TTK2009]_. This implementation skips the output carry compution.</span>


<span class="sd">    :param X: First register of size n to add.</span>
<span class="sd">    :param Y: Second register of size n to add.</span>
<span class="sd">    :param label: An optional label for the gate.</span>
<span class="sd">    :raises CircuitError: If X and Y have a different size.</span>

<span class="sd">    :operation: :math:`X \leftarrow X+Y \bmod 2^n`</span>

<span class="sd">    .. [TTK2009] Takahashi, Y., Tani, S., &amp; Kunihiro, N. (2009). Quantum addition circuits and unbounded fan-out. arXiv preprint arXiv:0910.2530.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">Y</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="s2">&quot;rADD operation must be between two QuantumRegisters of the same size.&quot;</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;rADD&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rADD&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>     
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">qc</span></div>


<div class="viewcode-block" id="simulate">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.simulate">[docs]</a>
<span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;automatic&#39;</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;CPU&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Counts</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This helper function simulates the given circuit and returns the results.</span>

<span class="sd">    :param circuit: The circuit to simulate.</span>
<span class="sd">    :param method: The method to use for the simulator.</span>
<span class="sd">    :param device: The device to run the simulation on (CPU or GPU).</span>
<span class="sd">    :returns: The result counts of the simulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">backend_sim</span> <span class="o">=</span> <span class="n">AerSimulator</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">=</span><span class="n">circuit</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">)</span>

    <span class="c1"># Transpile the circuit to convert rOperations into basis gates</span>
    <span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend_sim</span><span class="p">)</span>

    <span class="n">job_sim</span> <span class="o">=</span> <span class="n">backend_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
    <span class="n">result_sim</span> <span class="o">=</span> <span class="n">job_sim</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">result_sim</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">counts</span></div>


<div class="viewcode-block" id="make_circuit">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.make_circuit">[docs]</a>
<span class="k">def</span> <span class="nf">make_circuit</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">input_registers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">],</span> <span class="n">output_registers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This helper function makes a circuit with registers as input and measurement operations for the output registers. It also prepares the initial values of the input registers.</span>

<span class="sd">    :param circuit: The base circuit that will be expanded with measurement operations and preparation operations.</span>
<span class="sd">    :param inputs: A list of the initial values to assign to the input registers.</span>
<span class="sd">    :param inputs_registers: A list of the input registers.</span>
<span class="sd">    :param output_registers: A list of the output registers.</span>
<span class="sd">    :returns: The final circuit containing the preparation step, the base circuit and the measurement step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy the circuit</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">Barrier</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">front</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Add classical registers for the output registers</span>
    <span class="n">classical_output_registers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">output_register</span> <span class="ow">in</span> <span class="n">output_registers</span><span class="p">:</span>
        <span class="n">classical_output_register</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_register</span><span class="p">))</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">classical_output_register</span><span class="p">)</span>
        <span class="n">classical_output_registers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">classical_output_register</span><span class="p">)</span>
    <span class="c1"># Prepare the input by initializing it to given values</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">input_register</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_registers</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rPrepare</span><span class="p">(</span><span class="n">input_register</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">input_register</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">front</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="c1"># Add measurements for the output</span>
    <span class="k">for</span> <span class="n">output_register</span><span class="p">,</span> <span class="n">classical_output_register</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output_registers</span><span class="p">,</span> <span class="n">classical_output_registers</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">output_register</span><span class="p">,</span> <span class="n">classical_output_register</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">qc</span></div>


<div class="viewcode-block" id="run_circuit">
<a class="viewcode-back" href="../../rOperations.html#pyqrypto.rOperations.run_circuit">[docs]</a>
<span class="k">def</span> <span class="nf">run_circuit</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;automatic&#39;</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;CPU&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This helper function simulates a given circuit and retrieves the integer values of the classical registers.</span>

<span class="sd">    :param circuit: The circuit to run.</span>
<span class="sd">    :param verbose: Print the raw result given by the simulator.</span>
<span class="sd">    :param method: The method to use for the simulator.</span>
<span class="sd">    :param device: The device to run the simulation on (CPU or GPU).</span>
<span class="sd">    :returns: A list of the integers stored in the classical registers of the circuit after the circuit has been simulated. It takes into account only the most frequent result.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Simulate the circuit</span>
    <span class="n">raw_result</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Circuit result:&quot;</span><span class="p">,</span> <span class="n">raw_result</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">raw_result</span><span class="o">.</span><span class="n">most_frequent</span><span class="p">()</span>
    <span class="c1"># Extract the output registers (result is MSB-first so we need to reverse the register order)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Convert the outputs to integers</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Vi Retault.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>