<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyqrypto.register_operations &mdash; pyqrypto 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/documentation_options.js?v=2709fde1"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyqrypto
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../register_operations.html">Register Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparkle.html">Sparkle</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyqrypto</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyqrypto.register_operations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyqrypto.register_operations</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A library of vectorial operations that can be applied to quantum registers.</span>

<span class="sd">Operations can be applied directly between registers, for example a bitwise</span>
<span class="sd">XOR or an addition. This is similar to how registers work on classical computers. Rotations, and</span>
<span class="sd">permutations in general, can be made without using any quantum gate because they just return a new</span>
<span class="sd">view on the qubits, i.e. a new :class:`QuantumRegister` that has the same logical qubits but in a</span>
<span class="sd">different order.</span>

<span class="sd">The aim of this library is to be able to implement classical algorithms on quantum computers, to</span>
<span class="sd">benefit from the speedup given by methods such as Grover&#39;s algorithm.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span><span class="p">,</span> <span class="n">log2</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">AncillaRegister</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">transpile</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">Gate</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.exceptions</span> <span class="kn">import</span> <span class="n">CircuitError</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">Barrier</span><span class="p">,</span> <span class="n">CCXGate</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Final</span><span class="p">,</span> <span class="n">Sequence</span>

    <span class="kn">from</span> <span class="nn">qiskit.result.counts</span> <span class="kn">import</span> <span class="n">Counts</span>


<span class="n">FEYNMAN_QC</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;The quantum cost of the Feynman gate (CNOT).&quot;&quot;&quot;</span>
<span class="n">TOFFOLI_QC</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="sd">&quot;&quot;&quot;The quantum cost of the Toffoli gate (CCNOT).&quot;&quot;&quot;</span>
<span class="n">SINGLE_QC</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;The quantum cost of a single qubit gate.&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_int_to_bits</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_bits</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert integer k into list of bits in LSB-first.</span>

<span class="sd">    :param  k: The integer to convert to list of bits.</span>
<span class="sd">    :param num_bits: The numbers of bits to use to encode k.</span>
<span class="sd">    :returns: A list of bits encoding k.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure k is in range</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">**</span><span class="n">num_bits</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> cannot be encoded on </span><span class="si">{</span><span class="n">num_bits</span><span class="si">}</span><span class="s2"> bits.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">:</span><span class="s2">0</span><span class="si">{</span><span class="n">num_bits</span><span class="si">}</span><span class="s2">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">_hamming_weight</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the Hamming weight of an integer.</span>

<span class="sd">    :param k: The integer to compute the Hamming weight of.</span>
<span class="sd">    :returns: The Hamming weight of k.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hamming_weight</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">k</span><span class="p">:</span>
        <span class="n">hamming_weight</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">&amp;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">hamming_weight</span>


<div class="viewcode-block" id="RegisterCircuit">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterCircuit">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterCircuit</span><span class="p">(</span><span class="n">QuantumCircuit</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A wrapper around :class:`QuantumCircuit`.</span>

<span class="sd">    It implements the logic needed to chain operations on quantum registers.</span>

<span class="sd">    It supports new operations that operate on whole quantum registers and handles</span>
<span class="sd">    rotations without using any gate by rewiring the circuit when needed. This being also a fully</span>
<span class="sd">    valid :class:`QuantumCircuit`, it is also possible to apply operations on single qubits as it is</span>
<span class="sd">    normally done in Qiskit.</span>

<span class="sd">    :param inputs: The quantum registers to use as the circuit inputs.</span>
<span class="sd">    :param kwargs: Other parameters to pass to the underlying :class:`QuantumCircuit` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterCircuit</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a register circuit with inputs and arguments for the quantum circuit.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterCircuit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Some statistics about the circuit.</span>

<span class="sd">        - :py:data:`quantum_cost`: The quantum cost of the circuit as defined by [FoM2009]_.</span>
<span class="sd">        - :py:data:`depth`: The circuit depth when register operations are decomposed into NOT,</span>
<span class="sd">          CNOT and CCNOT gates.</span>
<span class="sd">        - :py:data:`gate_counts`: The number of basic gates in the circuit.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Quantum cost computation only works if the circuit contains only register</span>
<span class="sd">            operations or NOT, CNOT, and CCNOT gates.</span>

<span class="sd">        .. [FoM2009]</span>
<span class="sd">            Mohammadi, M., &amp; Eshghi, M. (2009). On figures of merit in reversible and</span>
<span class="sd">            quantum logic designs. Quantum Information Processing, 8, 297-318.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;ancilla&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancillas</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;qubits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancillas</span>

        <span class="c1"># Decompose all register operations in the circuit</span>
        <span class="n">decomposed_circuit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">gates_to_decompose</span><span class="o">=</span><span class="p">[</span><span class="n">RegisterOperation</span><span class="p">])</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="n">decomposed_circuit</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instruction</span><span class="o">.</span><span class="n">operation</span><span class="p">,</span> <span class="n">RegisterOperation</span><span class="p">):</span>
                    <span class="n">decomposed_circuit</span> <span class="o">=</span> <span class="n">decomposed_circuit</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span>
                        <span class="n">gates_to_decompose</span><span class="o">=</span><span class="p">[</span><span class="n">RegisterOperation</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
        <span class="n">operations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">decomposed_circuit</span><span class="o">.</span><span class="n">count_ops</span><span class="p">())</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;gate_counts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">operations</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;quantum_cost&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">operation</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">operations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;cx&quot;</span><span class="p">:</span>
                <span class="n">cost</span> <span class="o">=</span> <span class="n">FEYNMAN_QC</span>
            <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;ccx&quot;</span><span class="p">:</span>
                <span class="n">cost</span> <span class="o">=</span> <span class="n">TOFFOLI_QC</span>
            <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                <span class="n">cost</span> <span class="o">=</span> <span class="n">SINGLE_QC</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot compute quantum cost for operation </span><span class="si">{</span><span class="n">operation</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;quantum_cost&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cost</span> <span class="o">*</span> <span class="n">count</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decomposed_circuit</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
        <span class="c1"># Some papers only count toffoli gates for the circuit depth</span>
        <span class="n">ccx_only</span> <span class="o">=</span> <span class="n">decomposed_circuit</span><span class="o">.</span><span class="n">copy_empty_like</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span> <span class="ow">in</span> <span class="n">decomposed_circuit</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">CCXGate</span><span class="p">):</span>
                <span class="n">ccx_only</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span><span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;toffoli_depth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ccx_only</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">stats</span>

<div class="viewcode-block" id="RegisterCircuit.ror">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterCircuit.ror">[docs]</a>
    <span class="k">def</span> <span class="nf">ror</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterCircuit</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumRegister</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Rotate right a register by a specified amount of qubits.</span>

<span class="sd">        :param X: The register to rotate.</span>
<span class="sd">        :param r: The number of qubits by which X should be rotated.</span>
<span class="sd">        :returns: The rotated register :math:`X&#39;`.</span>

<span class="sd">        :operation: :math:`X&#39; \leftarrow \mathrm{ror}(X, r)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">operation</span> <span class="o">=</span> <span class="n">RegisterROR</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="RegisterCircuit.rol">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterCircuit.rol">[docs]</a>
    <span class="k">def</span> <span class="nf">rol</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterCircuit</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumRegister</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Rotate left a register by a specified amount of qubits.</span>

<span class="sd">        :param X: The register to rotate.</span>
<span class="sd">        :param r: The number of qubits by which X should be rotated.</span>
<span class="sd">        :returns: The rotated register :math:`X&#39;`.</span>

<span class="sd">        :operation: :math:`X&#39; \leftarrow \mathrm{rol}(X, r)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">operation</span> <span class="o">=</span> <span class="n">RegisterROL</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="RegisterCircuit.xor">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterCircuit.xor">[docs]</a>
    <span class="k">def</span> <span class="nf">xor</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterCircuit</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">Y</span><span class="p">:</span> <span class="n">QuantumRegister</span> <span class="o">|</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumRegister</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a bitwise XOR between two registers or between one register and a constant.</span>

<span class="sd">        :param X: The first register to XOR (the result will be stored in this register, overwriting</span>
<span class="sd">          its previous value).</span>
<span class="sd">        :param Y: The second register to XOR or a constant.</span>
<span class="sd">        :returns: The output register :math:`X`.</span>

<span class="sd">        :operation: :math:`X \leftarrow X \oplus Y`</span>

<span class="sd">        .. note::</span>
<span class="sd">            If Y is a :class:`QuantumRegister`, this operation is a XOR between two registers,</span>
<span class="sd">            but if Y is an integer it becomes a XOR between a register and a constant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">):</span>
            <span class="n">operation</span> <span class="o">=</span> <span class="n">RegisterXOR</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">operation</span> <span class="o">=</span> <span class="n">RegisterConstantXOR</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="RegisterCircuit.neg">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterCircuit.neg">[docs]</a>
    <span class="k">def</span> <span class="nf">neg</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterCircuit</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumRegister</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a bitwise NOT on a register.</span>

<span class="sd">        :param X: The register to apply the NOT to.</span>
<span class="sd">        :returns: The output register :math:`X`.</span>

<span class="sd">        :operation: :math:`X \leftarrow \neg X`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">operation</span> <span class="o">=</span> <span class="n">RegisterNOT</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="RegisterCircuit.add">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterCircuit.add">[docs]</a>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">RegisterCircuit</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span>
        <span class="n">Y</span><span class="p">:</span> <span class="n">QuantumRegister</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">ancillas</span><span class="p">:</span> <span class="n">AncillaRegister</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ripple&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumRegister</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Add modulo :math:`2^n` two registers of size n or a register of size n and a constant.</span>

<span class="sd">        The adder can be implemented using different techniques:</span>

<span class="sd">        - :py:data:`ripple`: requires 0 ancilla qubits, uses the ripple-carry method</span>
<span class="sd">          from [TTK2009]_.</span>
<span class="sd">        - :py:data:`lookahead`: requires :math:`2n-w(n-1)-\lfloor \log(n-1) \rfloor-2` ancilla</span>
<span class="sd">          qubits, uses the carry-lookahead method from [DKRS2004]_.</span>

<span class="sd">        :param X: First register to add (the result will be stored in this register, overwriting</span>
<span class="sd">          its previous value).</span>
<span class="sd">        :param Y: Second register to add or a constant.</span>
<span class="sd">        :param ancillas: The anquilla register needed in :py:data:`lookahead` mode.</span>
<span class="sd">        :mode: The type of adder to use.</span>
<span class="sd">        :returns: The output register :math:`X`.</span>

<span class="sd">        :operation: :math:`X \leftarrow X+Y \bmod 2^n`</span>

<span class="sd">        .. note::</span>
<span class="sd">            If Y is a :class:`QuantumRegister`, this operation is an addition between two registers,</span>
<span class="sd">            but if Y is an integer it becomes an addition between a register and a constant. In the</span>
<span class="sd">            latter case, the mode is always :py:data:`lookahead`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;ripple&quot;</span><span class="p">:</span>
                <span class="n">operation</span> <span class="o">=</span> <span class="n">RegisterTTKRippleCarryAdder</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;lookahead&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ancillas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot make a carry-lookahead adder without ancilla qubits.&quot;</span>
                    <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">operation</span> <span class="o">=</span> <span class="n">RegisterDKRSCarryLookaheadAdder</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unknown adder mode </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ancillas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot make a constant adder without ancilla qubits.&quot;</span>
                <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">operation</span> <span class="o">=</span> <span class="n">RegisterConstantDKRSCarryLookaheadAdder</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="RegisterOperation">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterOperation">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterOperation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An operation on registers of qubits.</span>

<span class="sd">    :ivar inputs: The inputs registers of the operation.</span>
<span class="sd">    :type inputs: Sequence[QuantumRegister]</span>
<span class="sd">    :ivar outputs: The outputs registers of the operation.</span>
<span class="sd">    :type outputs: Sequence[QuantumRegister]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterOperation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a register operation.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterOperation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the outputs of the operation.</span>

<span class="sd">        :returns: A list containing the output quantum registers of the operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterOperation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the inputs of the operation.</span>

<span class="sd">        :returns: A list containing the input quantum registers of the operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span></div>



<div class="viewcode-block" id="RegisterPrepare">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterPrepare">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterPrepare</span><span class="p">(</span><span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">RegisterOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A circuit preparing a QuantumRegister to an initial classical integer value.</span>

<span class="sd">    :param X: The register to prepare.</span>
<span class="sd">    :param value: The value to prepare the register to.</span>

<span class="sd">    :operation: :math:`X \leftarrow \mathrm{value}`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterPrepare</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RegisterPrepare operation.&quot;&quot;&quot;</span>
        <span class="n">num_qubits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;rPrepare </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">_int_to_bits</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">QuantumCircuit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">circuit</span><span class="o">.</span><span class="n">qregs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;rPrepare </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">RegisterOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">to_gate</span><span class="p">(),</span> <span class="n">qubits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span></div>



<div class="viewcode-block" id="RegisterROR">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterROR">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterROR</span><span class="p">(</span><span class="n">RegisterOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Defines the right rotation operation on a quantum register.</span>

<span class="sd">    :param X: The register to rotate.</span>
<span class="sd">    :param r: The number of qubits by which X should be rotated.</span>
<span class="sd">    :raises CircuitError: If r is negative.</span>

<span class="sd">    :operation: :math:`X&#39; \leftarrow \mathrm{ror}(X, r)`</span>

<span class="sd">    .. warning::</span>
<span class="sd">        The result will be stored in register :attr:`self.outputs[0]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterROR</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RegisterROR operation.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Rotation must be by a positive amount.&quot;</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span> <span class="o">+</span> <span class="n">X</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span></div>



<div class="viewcode-block" id="RegisterROL">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterROL">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterROL</span><span class="p">(</span><span class="n">RegisterOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Defines the left rotation operation on a quantum register.</span>

<span class="sd">    :param X: The register to rotate.</span>
<span class="sd">    :param r: The number of qubits by which X should be rotated.</span>
<span class="sd">    :raises CircuitError: If r is negative.</span>

<span class="sd">    :operation: :math:`X&#39; \leftarrow \mathrm{rol}(X, r)`</span>

<span class="sd">    .. warning::</span>
<span class="sd">        The result will be stored in register :attr:`self.outputs[0]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">RegisterROL</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RegisterROL operation.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Rotation must be by a positive amount.&quot;</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="n">r</span><span class="p">:]</span> <span class="o">+</span> <span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="n">r</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span></div>



<div class="viewcode-block" id="RegisterConstantXOR">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterConstantXOR">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterConstantXOR</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">RegisterOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Bitwise XOR between a quantum register and a constant.</span>

<span class="sd">    :param X: The register to XOR with c.</span>
<span class="sd">    :param c: The constant to XOR with X.</span>
<span class="sd">    :param label: An optional label for the gate.</span>

<span class="sd">    :operation: :math:`X \leftarrow X \oplus c`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">RegisterConstantXOR</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span>
        <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RegisterConstantXOR operation.&quot;&quot;&quot;</span>
        <span class="n">RegisterOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Gate</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rXORc&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>

        <span class="n">bits</span> <span class="o">=</span> <span class="n">_int_to_bits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;rXOR </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bits</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bit</span><span class="p">:</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">circuit</span></div>



<div class="viewcode-block" id="RegisterNOT">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterNOT">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterNOT</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">RegisterOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Bitwise NOT on a quantum register.</span>

<span class="sd">    :param X: The register to apply NOT on.</span>
<span class="sd">    :param label: An optional label for the gate.</span>

<span class="sd">    :oopoeration: :math:`X \leftarrow \neg X`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">RegisterNOT</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RegisterNOT operation.&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">RegisterOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Gate</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rNOT&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">]</span>

        <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rNOT&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">qbit</span> <span class="ow">in</span> <span class="n">X</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qbit</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">circuit</span></div>



<div class="viewcode-block" id="RegisterXOR">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterXOR">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterXOR</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">RegisterOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Bitwise XOR operation between two quantum registers.</span>

<span class="sd">    :param X: The first register to XOR.</span>
<span class="sd">    :param Y: The second register to XOR.</span>
<span class="sd">    :param label: An optional label for the gate.</span>
<span class="sd">    :raises CircuitError: If X and Y have a different size.</span>

<span class="sd">    :operation: :math:`X \leftarrow X \oplus Y`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">RegisterXOR</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span>
        <span class="n">Y</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RegisterXOR operation.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;rXOR operation must be between two QuantumRegisters of the same size.&quot;</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">RegisterOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Gate</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rXOR&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span>

        <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rXOR&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">circuit</span></div>



<div class="viewcode-block" id="RegisterConstantDKRSCarryLookaheadAdder">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterConstantDKRSCarryLookaheadAdder">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterConstantDKRSCarryLookaheadAdder</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">RegisterOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Addition modulo :math:`2^n` between a quantum register and a constant.</span>

<span class="sd">    :param X: The register of size n to add c to.</span>
<span class="sd">    :param c: The constant to add to X.</span>
<span class="sd">    :param label: An optional label for the gate.</span>

<span class="sd">    :operation: :math:`X \leftarrow X + c`</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RegisterConstantDKRSCarryLookaheadAdder.get_num_ancilla_qubits">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterConstantDKRSCarryLookaheadAdder.get_num_ancilla_qubits">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_num_ancilla_qubits</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of required ancilla qubits without instantiating the class.</span>

<span class="sd">        :param n: The number of qubits of the vectors to add.</span>
<span class="sd">        :returns: The number of ancilla qubits needed for the computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RegisterDKRSCarryLookaheadAdder</span><span class="o">.</span><span class="n">get_num_ancilla_qubits</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">RegisterConstantDKRSCarryLookaheadAdder</span><span class="p">,</span>
        <span class="n">A</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span>
        <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">ancillas</span><span class="p">:</span> <span class="n">AncillaRegister</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RegisterConstantDKRSCarryLookaheadAdder operation.&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">RegisterOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Gate</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rADDc&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">),</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_ancilla_qubits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Circuit needs </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_ancilla_qubits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;ancilla qubits but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">)</span><span class="si">}</span><span class="s2"> were given.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">circuit</span> <span class="o">=</span> <span class="n">RegisterCircuit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;rADD </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bits</span> <span class="o">=</span> <span class="n">_int_to_bits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">ancillas</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">ancillas</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="p">:])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Z[i] = g[i, i+1]</span>
                <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>  <span class="c1"># A[i] = p[i, i+1] and A[0] = s0</span>

            <span class="c1"># Lookahead carry</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Compute carry</span>
                <span class="n">compute_carry</span> <span class="o">=</span> <span class="n">RegisterDKRSComputeCarry</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Z</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute_carry</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">compute_carry</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>

                <span class="c1"># Compute sum</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">Z</span><span class="p">)</span>  <span class="c1"># A[i] = si</span>
                <span class="c1"># Now do everything in reverse</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># A = s&#39;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">circuit</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span>
                        <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="p">)</span>

                <span class="n">uncompute_carry</span> <span class="o">=</span> <span class="n">RegisterDKRSComputeCarry</span><span class="p">(</span>
                    <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">Z</span><span class="p">,</span>
                    <span class="n">X</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">reverse_ops</span><span class="p">()</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uncompute_carry</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">uncompute_carry</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">circuit</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span>
                        <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">circuit</span></div>



<div class="viewcode-block" id="RegisterDKRSComputeCarry">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterDKRSComputeCarry">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterDKRSComputeCarry</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">RegisterOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Carry computation as described in [DKRS2004]_.</span>

<span class="sd">    The last carry is not computed.</span>

<span class="sd">    :param P0: Represents :math:`P_0[i] = p[i, i+1]`, which is 1 if and only if carry propagages</span>
<span class="sd">      from bit :math:`i` to bit :math:`i+1`.</span>
<span class="sd">    :param G: Represents :math:`G[i] = g[i-1, i]`, which is 1 if and only if a carry is generated</span>
<span class="sd">      between bit :math:`i-1` and bit :math:`i`.</span>
<span class="sd">    :param ancillas: The ancilla qubits used for the computation. They must be set to 0 before the</span>
<span class="sd">      circuit and will be reset to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">RegisterDKRSComputeCarry</span><span class="p">,</span>
        <span class="n">P0</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">],</span>
        <span class="n">G</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">],</span>
        <span class="n">ancillas</span><span class="p">:</span> <span class="n">AncillaRegister</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RegisterDKRSComputeCarry operation.&quot;&quot;&quot;</span>
        <span class="n">RegisterOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Gate</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rCarry&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">),</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">P0</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">P0</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>

        <span class="n">circuit</span> <span class="o">=</span> <span class="n">RegisterCircuit</span><span class="p">(</span><span class="n">P0</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rCarry&quot;</span><span class="p">)</span>

        <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">P0</span><span class="p">]</span>
        <span class="n">ancilla_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))):</span>
            <span class="n">pt_size</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">ancillas</span><span class="p">[</span><span class="n">ancilla_index</span> <span class="p">:</span> <span class="n">ancilla_index</span> <span class="o">+</span> <span class="n">pt_size</span><span class="p">]))</span>
            <span class="n">ancilla_index</span> <span class="o">+=</span> <span class="n">pt_size</span>

        <span class="c1"># P-rounds</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">)):</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># G-rounds</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">)):</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># C rounds</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># P^-1 rounds</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">)):</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">circuit</span></div>



<div class="viewcode-block" id="RegisterDKRSCarryLookaheadAdder">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterDKRSCarryLookaheadAdder">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterDKRSCarryLookaheadAdder</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">RegisterOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A n qubits carry-lookahead adder modulo :math:`2^n`.</span>

<span class="sd">    It implements the adder described in [DKRS2004]_ but skips the output carry compution.</span>

<span class="sd">    :param A: First register of size n to add.</span>
<span class="sd">    :param B: Second register of size n to add.</span>
<span class="sd">    :param ancillas: The ancilla qubits used for the computation. They must be set to 0 before the</span>
<span class="sd">      circuit and will be reset to 0.</span>
<span class="sd">    :param label: An optional label for the gate.</span>
<span class="sd">    :raises CircuitError: If A and B have a different size or if there is not the correct number of</span>
<span class="sd">      ancilla qubits.</span>

<span class="sd">    :operation: :math:`X \leftarrow X+Y \bmod 2^n`</span>

<span class="sd">    .. [DKRS2004]</span>
<span class="sd">        Draper, T. G., Kutin, S. A., Rains, E. M., &amp; Svore, K. M. (2004).</span>
<span class="sd">        A logarithmic-depth quantum carry-lookahead adder. arXiv preprint quant-ph/0406142.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RegisterDKRSCarryLookaheadAdder.get_num_ancilla_qubits">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterDKRSCarryLookaheadAdder.get_num_ancilla_qubits">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_num_ancilla_qubits</span><span class="p">(</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of required ancilla qubits without instantiating the class.</span>

<span class="sd">        :param n: The number of qubits of the vectors to add.</span>
<span class="sd">        :returns: The number of ancilla qubits needed for the computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="n">_hamming_weight</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">RegisterDKRSCarryLookaheadAdder</span><span class="p">,</span>
        <span class="n">A</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span>
        <span class="n">ancillas</span><span class="p">:</span> <span class="n">AncillaRegister</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RegisterDKRSCarryLookaheadAdder operation.&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">RegisterOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Gate</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rADD&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">),</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;rADD operation must be between two QuantumRegisters of the same size.&quot;</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">RegisterCircuit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rADD&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancillas</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_ancilla_qubits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Wrong number of ancilla qubits.&quot;</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">ancillas</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">ancillas</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Z[i] = g[i, i+1]</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>  <span class="c1"># A[i] = p[i, i+1] and A[0] = s0</span>

        <span class="c1"># Lookahead carry</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Compute carry</span>
            <span class="n">compute_carry</span> <span class="o">=</span> <span class="n">RegisterDKRSComputeCarry</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Z</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute_carry</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">compute_carry</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>

            <span class="c1"># Compute sum</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">Z</span><span class="p">)</span>  <span class="c1"># A[i] = si</span>
            <span class="c1"># Now do everything in reverse</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># A = s&#39;</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

            <span class="n">uncompute_carry</span> <span class="o">=</span> <span class="n">RegisterDKRSComputeCarry</span><span class="p">(</span>
                <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">Z</span><span class="p">,</span>
                <span class="n">X</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reverse_ops</span><span class="p">()</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uncompute_carry</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">uncompute_carry</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>

            <span class="n">circuit</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">bits</span><span class="o">=</span><span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">circuit</span></div>



<div class="viewcode-block" id="RegisterTTKRippleCarryAdder">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.RegisterTTKRippleCarryAdder">[docs]</a>
<span class="k">class</span> <span class="nc">RegisterTTKRippleCarryAdder</span><span class="p">(</span><span class="n">Gate</span><span class="p">,</span> <span class="n">RegisterOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A gate implementing the n qubits ripple-carry adder modulo :math:`2^n`.</span>

<span class="sd">    It implements the adder described in [TTK2009]_ but skips the output carry compution.</span>

<span class="sd">    :param X: First register of size n to add.</span>
<span class="sd">    :param Y: Second register of size n to add.</span>
<span class="sd">    :param label: An optional label for the gate.</span>
<span class="sd">    :raises CircuitError: If X and Y have a different size.</span>

<span class="sd">    :operation: :math:`X \leftarrow X+Y \bmod 2^n`</span>

<span class="sd">    .. [TTK2009]</span>
<span class="sd">        Takahashi, Y., Tani, S., &amp; Kunihiro, N. (2009). Quantum addition circuits and</span>
<span class="sd">        unbounded fan-out. arXiv preprint arXiv:0910.2530.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">RegisterTTKRippleCarryAdder</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span>
        <span class="n">Y</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RegisterTTKRippleCarryAdder operation.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;rADD operation must be between two QuantumRegisters of the same size.&quot;</span>
            <span class="k">raise</span> <span class="n">CircuitError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">RegisterOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Gate</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rADD&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span>

        <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rADD&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">circuit</span></div>



<div class="viewcode-block" id="simulate">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.simulate">[docs]</a>
<span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;automatic&quot;</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CPU&quot;</span><span class="p">,</span>
    <span class="n">shots</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Counts</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulate the given circuit and returns the results.</span>

<span class="sd">    :param circuit: The circuit to simulate.</span>
<span class="sd">    :param method: The method to use for the simulator.</span>
<span class="sd">    :param device: The device to run the simulation on (CPU or GPU).</span>
<span class="sd">    :param shots: The number of times to run the simulation.</span>
<span class="sd">    :returns: The result counts of the simulation.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function needs the `qiskit_aer` extra dependency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># pylint: disable=import-outside-toplevel</span>
        <span class="kn">from</span> <span class="nn">qiskit_aer.backends</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">AerSimulator</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Manually set max_memory_mb to INT_MAX</span>
        <span class="c1"># workaround for https://github.com/Qiskit/qiskit-aer/issues/2056</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;matrix_product_state&quot;</span><span class="p">:</span>
            <span class="n">backend_sim</span> <span class="o">=</span> <span class="n">AerSimulator</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                <span class="n">n_qubits</span><span class="o">=</span><span class="n">circuit</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">,</span>
                <span class="n">max_memory_mb</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">backend_sim</span> <span class="o">=</span> <span class="n">AerSimulator</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">=</span><span class="n">circuit</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">)</span>

        <span class="c1"># Transpile the circuit to convert register operations into basis gates</span>
        <span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend_sim</span><span class="p">)</span>

        <span class="n">job_sim</span> <span class="o">=</span> <span class="n">backend_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
        <span class="n">result_sim</span> <span class="o">=</span> <span class="n">job_sim</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_sim</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;qiskit_aer is not installed. Please install it to use the simulate function.&quot;</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span></div>



<div class="viewcode-block" id="make_circuit">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.make_circuit">[docs]</a>
<span class="k">def</span> <span class="nf">make_circuit</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">input_registers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">],</span>
    <span class="n">output_registers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumRegister</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumCircuit</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a circuit with registers as input and measurement operations for the output registers.</span>

<span class="sd">    Also prepare the initial values of the input registers.</span>

<span class="sd">    :param circuit: The base circuit that will be expanded with measurement operations and</span>
<span class="sd">      preparation operations.</span>
<span class="sd">    :param inputs: A list of the initial values to assign to the input registers.</span>
<span class="sd">    :param inputs_registers: A list of the input registers.</span>
<span class="sd">    :param output_registers: A list of the output registers.</span>
<span class="sd">    :returns: The final circuit containing the preparation step, the base circuit and the</span>
<span class="sd">      measurement step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy the circuit</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">Barrier</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">front</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Add classical registers for the output registers</span>
    <span class="n">classical_output_registers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">output_register</span> <span class="ow">in</span> <span class="n">output_registers</span><span class="p">:</span>
        <span class="n">classical_output_register</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_register</span><span class="p">))</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">classical_output_register</span><span class="p">)</span>
        <span class="n">classical_output_registers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">classical_output_register</span><span class="p">)</span>
    <span class="c1"># Prepare the input by initializing it to given values</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">input_register</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_registers</span><span class="p">):</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span>
            <span class="n">RegisterPrepare</span><span class="p">(</span>
                <span class="n">input_register</span><span class="p">,</span>
                <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="p">),</span>
            <span class="n">input_register</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">front</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="c1"># Add measurements for the output</span>
    <span class="k">for</span> <span class="n">output_register</span><span class="p">,</span> <span class="n">classical_output_register</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">output_registers</span><span class="p">,</span>
        <span class="n">classical_output_registers</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">output_register</span><span class="p">,</span> <span class="n">classical_output_register</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circuit</span></div>



<div class="viewcode-block" id="run_circuit">
<a class="viewcode-back" href="../../register_operations.html#pyqrypto.register_operations.run_circuit">[docs]</a>
<span class="k">def</span> <span class="nf">run_circuit</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;automatic&quot;</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CPU&quot;</span><span class="p">,</span>
    <span class="n">shots</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulate a circuit and retrieve the integer values of the classical registers.</span>

<span class="sd">    :param circuit: The circuit to run.</span>
<span class="sd">    :param method: The method to use for the simulator.</span>
<span class="sd">    :param device: The device to run the simulation on (CPU or GPU).</span>
<span class="sd">    :param shots: The number of times to run the simulation.</span>
<span class="sd">    :returns: A list of the integers stored in the classical registers of the circuit after the</span>
<span class="sd">      circuit has been simulated. It takes into account only the most frequent result.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function needs the `qiskit_aer` extra dependency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Simulate the circuit</span>
    <span class="n">raw_result</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">raw_result</span><span class="o">.</span><span class="n">most_frequent</span><span class="p">()</span>
    <span class="c1"># Extract the output registers (result is MSB-first so we need to reverse the register order)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Convert the outputs to integers</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Vi Retault.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>