<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Welcome to pyqrypto’s documentation! &mdash; pyqrypto 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/documentation_options.js?v=2709fde1"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Register Operations" href="register_operations.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            pyqrypto
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="register_operations.html">Register Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="sparkle.html">Sparkle</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">pyqrypto</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Welcome to pyqrypto’s documentation!</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/g33kex/pyqrypto/blob/main/docs/source/index.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="welcome-to-pyqrypto-s-documentation">
<h1>Welcome to pyqrypto’s documentation!<a class="headerlink" href="#welcome-to-pyqrypto-s-documentation" title="Link to this heading">¶</a></h1>
<p><strong>pyrypto</strong> is a library of reversible quantum circuits for basic functions used in classical cryptography. As of now it implements the ARX-box Alzette and the associated tweakable block cipher TRAX from the <a class="reference external" href="https://sparkle-lwc.github.io/">Sparkle-suite</a> and their necessary gates. It is easily expandable to more ciphers.</p>
<p>This library provides high level operations on quantum registers by tracking the individual qubits. Because of this, permutations can be implemented for free. Additionally, the quantum cost of a circuit containing these operations can be automatically computed.</p>
<p>This library is based on <a class="reference external" href="https://qiskit.org/">Qiskit</a>.</p>
<section id="implemented-gates">
<h2>Implemented Gates<a class="headerlink" href="#implemented-gates" title="Link to this heading">¶</a></h2>
<p>These are the quantum gates currently implemented by this project.</p>
<ul class="simple">
<li><p><a class="reference internal" href="sparkle.html#pyqrypto.sparkle.TraxlEnc" title="pyqrypto.sparkle.TraxlEnc"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraxlEnc</span></code></a> - TRAX-L encryption</p></li>
<li><p><a class="reference internal" href="sparkle.html#pyqrypto.sparkle.Alzette" title="pyqrypto.sparkle.Alzette"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alzette</span></code></a> - a 64 bit ARX-box</p></li>
<li><p><a class="reference internal" href="register_operations.html#pyqrypto.register_operations.RegisterTTKRippleCarryAdder" title="pyqrypto.register_operations.RegisterTTKRippleCarryAdder"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegisterTTKRippleCarryAdder</span></code></a> - ripple carry adder</p></li>
<li><p><a class="reference internal" href="register_operations.html#pyqrypto.register_operations.RegisterDKRSCarryLookaheadAdder" title="pyqrypto.register_operations.RegisterDKRSCarryLookaheadAdder"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegisterDKRSCarryLookaheadAdder</span></code></a> - carry lookahead adder</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">RegisterConstantDKRSCarryLookaheadAdder`</span></code> - carry lookahead adder with a constant</p></li>
<li><p><a class="reference internal" href="register_operations.html#pyqrypto.register_operations.RegisterXOR" title="pyqrypto.register_operations.RegisterXOR"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegisterXOR</span></code></a> - bitwise XOR</p></li>
<li><p><a class="reference internal" href="register_operations.html#pyqrypto.register_operations.RegisterConstantXOR" title="pyqrypto.register_operations.RegisterConstantXOR"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegisterConstantXOR</span></code></a> - bitwise XOR with a constant</p></li>
<li><p><a class="reference internal" href="register_operations.html#pyqrypto.register_operations.RegisterNOT" title="pyqrypto.register_operations.RegisterNOT"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegisterNOT</span></code></a> - bitwise NOT</p></li>
<li><p><a class="reference internal" href="register_operations.html#pyqrypto.register_operations.RegisterROR" title="pyqrypto.register_operations.RegisterROR"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegisterROR</span></code></a> - right rotation (gate free)</p></li>
<li><p><a class="reference internal" href="register_operations.html#pyqrypto.register_operations.RegisterROL" title="pyqrypto.register_operations.RegisterROL"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegisterROL</span></code></a> - left rotation (gate free)</p></li>
</ul>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h2>
<p>Here are some usage examples for <strong>pyqrypto</strong>. Checkout the  <a class="reference external" href="https://github.com/g33kex/pyqrypto/tree/main/examples">examples folder</a> for more.</p>
<section id="simple-usage">
<h3>Simple Usage<a class="headerlink" href="#simple-usage" title="Link to this heading">¶</a></h3>
<p>Here is an example on how to use <strong>pyqrypto</strong> to generate a simple circuit that operates on qubit vectors.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqrypto.register_operations</span> <span class="kn">import</span> <span class="n">RegisterCircuit</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumRegister</span>

<span class="c1"># Create two 4 qubit registers</span>
<span class="n">X1</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="n">Y1</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Y&quot;</span><span class="p">)</span>

<span class="c1"># Create a register circuit from registers X and Y.</span>
<span class="c1"># A register circuit can operate on quantum registers instead of on individual qubits.</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">RegisterCircuit</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">Y1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rCircuit&quot;</span><span class="p">)</span>

<span class="c1"># Rotate left register X by 3 qubits.</span>
<span class="c1"># A register can be seen as a &quot;view&quot; on logical qubits,</span>
<span class="c1"># so rotating a register just yields another view on these qubits with swapped indexes.</span>
<span class="n">X2</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">ror</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># Let&#39;s XOR X2 Y1. The result will be stored in X3.</span>
<span class="c1"># Note here that X3 = X2 because xor doesn&#39;t modify the view.</span>
<span class="n">X3</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">Y1</span><span class="p">)</span>

<span class="c1"># If we print the resulting circuit, we can see the XOR was done on a rotated version of X1.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">decompose</span><span class="p">())</span>
<span class="c1">#           ┌───┐</span>
<span class="c1"># X_0: ─────┤ X ├──────────</span>
<span class="c1">#           └─┬─┘┌───┐</span>
<span class="c1"># X_1: ───────┼──┤ X ├─────</span>
<span class="c1">#             │  └─┬─┘┌───┐</span>
<span class="c1"># X_2: ───────┼────┼──┤ X ├</span>
<span class="c1">#      ┌───┐  │    │  └─┬─┘</span>
<span class="c1"># X_3: ┤ X ├──┼────┼────┼──</span>
<span class="c1">#      └─┬─┘  │    │    │</span>
<span class="c1"># Y_0: ──■────┼────┼────┼──</span>
<span class="c1">#             │    │    │</span>
<span class="c1"># Y_1: ───────■────┼────┼──</span>
<span class="c1">#                  │    │</span>
<span class="c1"># Y_2: ────────────■────┼──</span>
<span class="c1">#                       │</span>
<span class="c1"># Y_3: ─────────────────■──</span>
</pre></div>
</div>
<p>The library also provides handy tools to add preparation steps and measurements to a circuit operating on quantum registers. The registers can be initialized to an integer initial value, and measurement gates can be automatically added and the values of the output of the classical registers converted to integers. This allows testing the circuit on real data to make sure the implementation is correct.</p>
<p>Let’s add a preparation and a measurement step to our previous example and simulate it.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You need to install the <a class="reference external" href="https://pypi.org/project/qiskit-aer/">qiskit-aer</a> extra dependency to use the simulation feature.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqrypto.register_operations</span> <span class="kn">import</span> <span class="n">make_circuit</span><span class="p">,</span> <span class="n">run_circuit</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">qasm3</span>

<span class="c1"># Create a final circuit with measurement and preparation steps</span>
<span class="c1"># Let&#39;s initialize X1 to 4 and Y1 to 11</span>
<span class="c1"># Let&#39;s also measure X2 and Y1 at the end of the circuit</span>
<span class="c1"># It is possible to measure any QuantumRegistrer that has its qubits in the circuit</span>
<span class="c1"># This means we can measure the final state of any &quot;view&quot; of the qubits</span>
<span class="c1"># However note that the qubits will be in their final state during the measurement</span>
<span class="c1"># If we tried to measure X1, we wouldn&#39;t get the initial value of X1</span>
<span class="c1"># but the value of X2 left rotated by 3 bits</span>
<span class="c1"># This is because the value of X1 was overwritten by the XOR operation.</span>
<span class="c1"># This is why it is important to keep track of your registers during operations!</span>
<span class="n">final_circuit</span> <span class="o">=</span> <span class="n">make_circuit</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="p">[</span><span class="n">X1</span><span class="p">,</span> <span class="n">Y1</span><span class="p">],</span> <span class="p">[</span><span class="n">X2</span><span class="p">,</span> <span class="n">Y1</span><span class="p">])</span>

<span class="c1"># We can print the final circuit</span>
<span class="c1"># As you can see the measurements are done on</span>
<span class="nb">print</span><span class="p">(</span><span class="n">final_circuit</span><span class="p">)</span>
<span class="c1">#       ┌─────────────┐ ┌───────┐   ┌─┐</span>
<span class="c1">#  X_0: ┤0            ├─┤1      ├───┤M├──────────────────</span>
<span class="c1">#       │             │ │       │   └╥┘┌─┐</span>
<span class="c1">#  X_1: ┤1            ├─┤2      ├────╫─┤M├───────────────</span>
<span class="c1">#       │  rPrepare 4 │ │       │    ║ └╥┘┌─┐</span>
<span class="c1">#  X_2: ┤2            ├─┤3      ├────╫──╫─┤M├────────────</span>
<span class="c1">#       │             │ │       │┌─┐ ║  ║ └╥┘</span>
<span class="c1">#  X_3: ┤3            ├─┤0      ├┤M├─╫──╫──╫─────────────</span>
<span class="c1">#       ├─────────────┴┐│  Rxor │└╥┘ ║  ║  ║ ┌─┐</span>
<span class="c1">#  Y_0: ┤0             ├┤4      ├─╫──╫──╫──╫─┤M├─────────</span>
<span class="c1">#       │              ││       │ ║  ║  ║  ║ └╥┘┌─┐</span>
<span class="c1">#  Y_1: ┤1             ├┤5      ├─╫──╫──╫──╫──╫─┤M├──────</span>
<span class="c1">#       │  rPrepare 11 ││       │ ║  ║  ║  ║  ║ └╥┘┌─┐</span>
<span class="c1">#  Y_2: ┤2             ├┤6      ├─╫──╫──╫──╫──╫──╫─┤M├───</span>
<span class="c1">#       │              ││       │ ║  ║  ║  ║  ║  ║ └╥┘┌─┐</span>
<span class="c1">#  Y_3: ┤3             ├┤7      ├─╫──╫──╫──╫──╫──╫──╫─┤M├</span>
<span class="c1">#       └──────────────┘└───────┘ ║  ║  ║  ║  ║  ║  ║ └╥┘</span>
<span class="c1"># c0: 4/══════════════════════════╩══╩══╩══╩══╬══╬══╬══╬═</span>
<span class="c1">#                                 0  1  2  3  ║  ║  ║  ║</span>
<span class="c1"># c1: 4/══════════════════════════════════════╩══╩══╩══╩═</span>
<span class="c1">#                                             0  1  2  3</span>

<span class="c1"># We can generate the QASM of that circuit and save it to a file</span>
<span class="c1"># This can be used to run the circuit on an actual quantum computer</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;circuit.qasm&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">qasm3</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">final_circuit</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

<span class="c1"># Let&#39;s run this circuit in a simulation and gather the result</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">run_circuit</span><span class="p">(</span><span class="n">final_circuit</span><span class="p">)</span>

<span class="c1"># We can verify that ror(4, 3)^11 = 3, and that Y1 was unchanged.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="c1"># [3, 11]</span>
</pre></div>
</div>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="addition">
<h3>Addition<a class="headerlink" href="#addition" title="Link to this heading">¶</a></h3>
<p>Here is an example on how to do a 8-bit addition using a ripple-carry adder:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s create two 8 bit quantum registers</span>
<span class="n">X1</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Y&quot;</span><span class="p">)</span>

<span class="n">qc</span> <span class="o">=</span> <span class="n">RegisterCircuit</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

<span class="c1"># X2 &lt;- X1 + Y</span>
<span class="c1"># By default, the adder used is a ripple-carry adder</span>
<span class="n">X2</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

<span class="c1"># Print the circuit</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># Let&#39;s test it by adding 74 and 42</span>
<span class="n">final_circuit</span> <span class="o">=</span> <span class="n">make_circuit</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="p">[</span><span class="mi">74</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span> <span class="p">[</span><span class="n">X1</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="p">[</span><span class="n">X2</span><span class="p">])</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">run_circuit</span><span class="p">(</span><span class="n">final_circuit</span><span class="p">)</span>

<span class="c1"># 74+42 = 116</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible to use a carry-lookahead adder to obtain a shallower circuit, at the expense of ancilla qubits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Performing operation </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">+</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Instanciate registers</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
<span class="c1"># Instanciate enough ancilla qubits</span>
<span class="n">ancillas</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">RegisterDKRSCarryLookaheadAdder</span><span class="o">.</span><span class="n">get_num_ancilla_qubits</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="c1"># Build circuit</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">RegisterCircuit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">ancillas</span><span class="o">=</span><span class="n">ancillas</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;lookahead&quot;</span><span class="p">)</span>

<span class="c1"># Print statistics about the circuit</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Circuit stats:&quot;</span><span class="p">,</span> <span class="n">qc</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>

<span class="c1"># Add initialization and measurements</span>
<span class="n">final_circuit</span> <span class="o">=</span> <span class="n">make_circuit</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">A</span><span class="p">])</span>

<span class="c1"># Run the circuit</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">run_circuit</span><span class="p">(</span><span class="n">final_circuit</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;matrix_product_state&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="alzette">
<h3>Alzette<a class="headerlink" href="#alzette" title="Link to this heading">¶</a></h3>
<p>Here’s how to use the <a class="reference internal" href="sparkle.html#pyqrypto.sparkle.Alzette" title="pyqrypto.sparkle.Alzette"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alzette</span></code></a> gate:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">from</span> <span class="nn">pyqrypto.register_operations</span> <span class="kn">import</span> <span class="n">RegisterCircuit</span><span class="p">,</span> <span class="n">make_circuit</span><span class="p">,</span> <span class="n">run_circuit</span>
<span class="kn">from</span> <span class="nn">pyqrypto.sparkle</span> <span class="kn">import</span> <span class="n">Alzette</span><span class="p">,</span> <span class="n">c_alzette</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">qasm3</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
<span class="c1"># Create two quantum registers</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Y&quot;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">384973</span> <span class="o">%</span> <span class="mi">2</span><span class="o">**</span><span class="n">n</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">1238444859</span> <span class="o">%</span> <span class="mi">2</span><span class="o">**</span><span class="n">n</span>
<span class="n">c</span> <span class="o">=</span> <span class="mh">0xB7E15162</span> <span class="o">%</span> <span class="mi">2</span><span class="o">**</span><span class="n">n</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running alzette_</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>


<span class="n">qc</span> <span class="o">=</span> <span class="n">RegisterCircuit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

<span class="c1"># Add the Alzette get</span>
<span class="n">gate</span> <span class="o">=</span> <span class="n">Alzette</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gate</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">gate</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>

<span class="c1"># Save the QASM to a file</span>
<span class="k">with</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;alzette.qasm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">qasm3</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span>

<span class="n">final_circuit</span> <span class="o">=</span> <span class="n">make_circuit</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">])</span>

<span class="c1"># Simulate the circuit</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">run_circuit</span><span class="p">(</span><span class="n">final_circuit</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;automatic&quot;</span><span class="p">)</span>

<span class="c1"># Print some statistics about the circuit (depth, gate counts and quantum cost)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Circuit stats:&quot;</span><span class="p">,</span> <span class="n">qc</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>
<span class="c1"># Make sure the classical result matches the quantum result</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Classical result: </span><span class="si">{</span><span class="n">c_alzette</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Quantum simulated result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="trax-l">
<h3>TRAX-L<a class="headerlink" href="#trax-l" title="Link to this heading">¶</a></h3>
<p>Here’s how to use the <a class="reference internal" href="sparkle.html#pyqrypto.sparkle.TraxlEnc" title="pyqrypto.sparkle.TraxlEnc"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraxlEnc</span></code></a> gate:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">from</span> <span class="nn">pyqrypto.register_operations</span> <span class="kn">import</span> <span class="n">RegisterCircuit</span><span class="p">,</span> <span class="n">make_circuit</span><span class="p">,</span> <span class="n">run_circuit</span>
<span class="kn">from</span> <span class="nn">pyqrypto.sparkle</span> <span class="kn">import</span> <span class="n">TraxlEnc</span><span class="p">,</span> <span class="n">c_traxl_enc</span><span class="p">,</span> <span class="n">c_traxl_genkeys</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">qasm3</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.quantumregister</span> <span class="kn">import</span> <span class="n">AncillaRegister</span>

<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the inputs, tweak and encryption key</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">tweak</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;x:&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;y:&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;key:&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="n">key</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tweak:&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="n">tweak</span><span class="p">)))</span>

<span class="c1"># Create the quantum registers</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;X</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">[</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Y</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">K</span> <span class="o">=</span> <span class="p">[</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;K</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>
<span class="n">ancillas</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">TraxlEnc</span><span class="o">.</span><span class="n">get_num_ancilla_qubits</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="c1"># Create the circuit and add the TRAX-L encryption gate</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">RegisterCircuit</span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">Y</span><span class="p">,</span> <span class="o">*</span><span class="n">K</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)</span>
<span class="n">gate</span> <span class="o">=</span> <span class="n">TraxlEnc</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">tweak</span><span class="p">,</span> <span class="n">ancillas</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gate</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">gate</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>

<span class="c1"># Print circuit statistics</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>

<span class="c1"># Save the QASM to a file</span>
<span class="k">with</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;traxl.qasm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">qasm3</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span>

<span class="c1"># Add state preparation and measurement</span>
<span class="n">final_circuit</span> <span class="o">=</span> <span class="n">make_circuit</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">key</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">inputs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">gate</span><span class="o">.</span><span class="n">outputs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Run the simulation (it might take a while)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">run_circuit</span><span class="p">(</span><span class="n">final_circuit</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;matrix_product_state&quot;</span><span class="p">)</span>

<span class="c1"># Print the results</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Quantum simulated results:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;quantum_x: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;quantum_y: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">8</span><span class="p">]))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;quantum_last_subkey: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">16</span><span class="p">]))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Do the same computation classically to compare the results</span>
<span class="n">subkeys</span> <span class="o">=</span> <span class="n">c_traxl_genkeys</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">true_x</span><span class="p">,</span> <span class="n">true_y</span> <span class="o">=</span> <span class="n">c_traxl_enc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">subkeys</span><span class="p">,</span> <span class="n">tweak</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;last_subkeys: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span><span class="w"> </span><span class="n">subkeys</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">::]))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;true_x: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span><span class="w"> </span><span class="n">true_x</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;true_y: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span><span class="w"> </span><span class="n">true_y</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">true_x</span> <span class="o">==</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="ow">and</span> <span class="n">true_y</span> <span class="o">==</span> <span class="n">result</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="register_operations.html" class="btn btn-neutral float-right" title="Register Operations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Vi Retault.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>